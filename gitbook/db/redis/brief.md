# Redis 基础

## Redis 特性

Redis是一个高性能的key-value存储系统，具有如下的特性：

### 速度快

+ 数据在内存中，内存相对于硬盘，访问速度更快
+ C语言编写
+ 单线程架构，预防了多线程可能产生的竞争问题

### 支持丰富的数据类型

+ string
+ list
+ set
+ sorted set
+ hash
+ 等

### 功能丰富

+ 提供了键过期功能，可以用来实现缓存
+ 提供了发布订阅功能，可以用来实现消息系统
+ 支持Lua脚本，可以利用Lua创造出新的Redis命令
+ 提供了简单的事务功能
+ 提供了pipeline功能，客户端能将一批命令一次性传到Redis执行，减少网络开销

### 支持持久化

redis所有的数据保存在内存中，对数据的更新将异步地保存到磁盘上，可选RDB/AOF

### 主从复制

Redis提供了主从复制功能，实现了多个相同数据的Redis副本

## Redis 应用场景

### 缓存

Redis提供了键值过期时间设置，并且也提供了灵活控制最大内存和内存溢出后的淘汰策略。是Redis最常见的应用场景

### 计数器

Redis天然支持计数器功能，而且计数的性能也非常好

### 排行榜系统

Redis提供了列表和有序集合数据结构，合理地使用这些数据结构可以很方便的构建各种排行榜系统。

### 消息队列系统

Redis 提供了发布订阅功能，可以用于实现消息队列系统。(不推荐使用Redis来做消息队列系统，专业的消息队列例如Kafka是更好的选择)

### 分布式锁

利用Redis SETNX 命令的原子性，可以实现分布式锁。（可以参考开源框架Redisson）

## Redis 数据类型

### 常用全局命令

+ 查看所有键： `keys *`
+ 键总数： `dbsize`
+ 检查键是否存在： `exits key`
+ 删除键： `del key [key...]`
+ 键过期： `expire key seconds`
+ 键对应的数据结构类型： `type key`

### 数据结构和内部编码

type 命令返回的是当前键的数据类型，这只是Redis对外的数据结构。实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的编码。

可以通过 `object encoding` 命令查询内部编码。

### 字符串 (Strings)

字符串是一种最基本的Redis值类型，

+ 二进制安全，可以包含任意任意类型的数据，例如：一张JPEG的图片，或者一个序列化的对象
+ 最多能存储512M字节的内容
+ 利用INCR命令簇(INCR,DECR,INCRBY) 来把字符串当作原子计数器使用
+ 利用APPEND命令在字符串后面添加内容
+ 将字符串作为GETRANGE 和 SETRANGE的随机访问向量

### 列表 (Lists)

Redis 列表是简单的字符串列表，

+ 按照插入顺序排序
+ 一个列表最多可以包含2^32 - 1个元素
+ 双向无环链表实现，在两端插入速度很快

### 集合 (Sets)

Redis 集合是一个无序的字符串合集，

+ 无重复元素
+ O(1)的时间复杂度完成添加删除操作
+ 一个集合最多可以包含2^32 - 1个元素
+ 支持求交集和并集等操作

### 哈希 (Hashes)

Redis Hashes是字符串字段和字符串值之间的映射，所以它们是完美的表示对象的数据类型

### 有序集合 (Sorted sets)

Redis有序集合和Redis集合类似，是不包含 相同字符串的合集。Redis有序集合和Redis集合类似，是不包含 相同字符串的合集

+ O(log(N))时间复杂度完成添加删除和更新元素的操作

## Redis 持久化

Redis 提供了多种不同级别的持久化方式：

+ RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照
+ AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾
+ Redis 还可以同时使用 AOF 和 RDB。在这种情况下，当Redis重启时，它会优先使用AOF文件来还原数据集，因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。
+ 可以关闭持久化功能

### RDB

#### RDB工作方式

当 Redis 需要保存 dump.rdb 文件时， 服务器执行以下操作:

+ Redis 调用forks. 同时拥有父进程和子进程
+ 子进程将数据集写入到一个临时 RDB 文件中
+ 当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件

#### RDB优点

+ RDB是一个非常紧凑的文件，它保存了某个时间点的数据集（快照），非常适用于数据集的备份和灾难恢复
+ RDB在保存RDB文件时父进程只需要fork出一个子进程，接下来写文件的工作全部由子进程来完成，父进程不需要再做其他IO操作，可以响应客户端的请求，所以RDB持久化方式可以最大化redis的性能。
+ 与AOF相比，在恢复大的数据集时，RDB方式会更快一些

#### RDB缺点

+ 相比AOF，数据不耐久
+ 在数据集非常庞大时，RDB以fork子进程方式会非常耗时

### AOF

#### AOF工作方式

每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。

#### AOF优点

+ 更耐久，可以使用不同的fsync策略，使用每秒fsync策略时，出现故障时最多丢失1秒的数据
+ AOF持久化完成的是对指令集的增加操作，相对于RDB的每次都拷贝整个数据集更加省时安全
+ AOF可以在文件体积过大时，在后台完成重写，并且这种重写由于AOF重写缓冲区的存在是安全的
+ AOF 文件有序地保存了对数据库执行的所有写入操作， 这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松

#### AOF缺点

+ 对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积
+ 根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB

## Redis数据过期

Redis key的过期时间和永久有效性可以通过`EXPIRE`和`PERSIST`命令来进行更新或者删除过期时间。Keys的过期时间使用Unix时间戳存储，这意味着即使Redis实例不可用，时间也是一直流逝的。

### Redis如何淘汰过期的keys

Redis keys过期有两种方式： 被动和主动方式

当一些客户端尝试访问它时，key会被发现并过期。因为有些过期的keys，永远不会访问他们，redis会定时随机测试设置keys的过期时间。

Redis 每100ms做以下动作：

+ 测试随机的20个keys进行相关过期检测
+ 删除所有已经过期的keys
+ 如果有多于25%的keys过期，重复步骤1

### 在复制AOF文件时如何处理过期

为了获得正确的行为而不牺牲一致性，当一个key过期，DEL将会随着AOF文字一起合成到所有附件的slaves。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。

当slaves连接到master时，不会独立过期keys(会等到master执行DEL命令)，他们仍然会在数据集里面存在，所以当slave当选为master时淘汰keys会独立执行，然后成为master。

## Redis作为缓存和LRU算法

当redis被当作缓存来使用，当新增数据时，可以设置redis进行自动回收旧数据。Redis的maxmemory指令用于将可用内存限制成一个固定大小。

### 回收策略

当maxmemory限制达到的时候Redis会使用的行为由 Redis的maxmemory-policy配置指令来进行配置。

有6种回收策略：

+ noeviction: 当内存限制达到并且客户端尝试执行会让更多内存被使用的命令时，返回错误
+ allkeys-lru: 尝试回收最少使用的键（LRU），使得新添加的数据有空间存放。
+ volatile-lru: 尝试回收最少使用的键（LRU），但仅限于在过期集合的键,使得新添加的数据有空间存放。
+ allkeys-random: 回收随机的键使得新添加的数据有空间存放
+ volatile-random: 回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键。
+ volatile-ttl: 回收在过期集合的键，并且优先回收存活时间（TTL）较短的键,使得新添加的数据有空间存放。

### 回收进程如何工作

回收进程的工作流程：

+ 一个客户端运行了新的命令，添加了新的数据
+ Redis检查内存使用情况，如果大于maxmemory的限制，则根据设定好的策略进行回收
+ 一个新的命令被执行，等等
+ 不断穿越内存限制的边界，通过不断到达边界然后不断得回收到边界以下。

### 近似LRU算法

Redis的LRU算法并非完整的实现。Redis并没有办法选择最佳候选来进行回收，也就是最久未被访问的键。Redis使用一种近似LRU算法，通过对少量keys进行取样，然后回收其中一个最好的key(被访问时间较早的)。可以通过调整每次回收时检查的采样数量(`maxmemory-samples`)，以实现调整算法的精度。

Redis为什么不使用真实的LRU实现是因为这需要太多的内存。经典的LRU算法使用HashMap+双端链表实现。

## 参考资料

+ [《Redis开发与运维》](https://book.douban.com/subject/26971561/)
+ [Redis中文文档](http://www.redis.cn/documentation.html)