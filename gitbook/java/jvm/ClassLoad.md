# 虚拟机类加载机制

虚拟机类加载机制： 虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型

## 类加载的时机

类的生命周期： 加载、验证、准备、解析、初始化、使用、卸载。其中，验证、准备、解析三个部分统称为连接(Linking)。

Java虚拟机规范并没有强制类加载的第一阶段--加载，但是对于初始化阶段，虚拟机规范严格规定了有且只有5种情况必须立即对类进行“初始化”

+ 遇到`new`、`getstatic`、`putstatic`、或者`invokestatic`这4条指令时，如果类没有进行过初始化，则需要先触发其初始化
+ 使用`java.lang.reflect`包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
+ 当初始化一个类时，如果发现其父类还没有进行过初始化，则需要先触发其触发其父类的初始化
+ 当虚拟机启动时，用户需要指定一个执行的主类（包含main()方法那个类），虚拟机会先初始化这个主类
+ 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发初始化

这五种场景中的行为称为对一个类的主动引用，除此之外，所有引用类的方式都不会触发初始化，称为被动引用。被动引用的例子：

+ 通过子类引用父类的静态字段，不会导致子类被初始化
+ 通过数组定义引用类，
+ 常量

## 类加载的过程

类加载的全过程包括： 加载、验证、准备、解析、初始化

### 加载

加载阶段，虚拟机需要完成三件事：

+ 通过一个类的全限定名来获取定义此类的二进制字节流
+ 将这个字节流带的静态存储结构转化为方法区的运行时数据
+ 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口

### 验证

验证是连接阶段的第一步，这一阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全

验证阶段大致会完成4个阶段的验证工作：

#### 1.文件格式验证(文件结构分析)

+ 是否以魔数0xCAFEBABE开头
+ 主、次版本号是否在当前虚拟机处理范围之类
+ 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）
+ 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量
+ CONSTANT_Utf8_info类型的常量中是否有不符合UTF8编码的数据
+ Class文件中各个部分及文件本身是否有被删除的或者附加的其他信息

#### 2.元数据验证(语义分析)

+ 这个类是否有父类（除了java.lang.Object外，所有的类都应当有父类）
+ 这个类的父类是否继承了不允许被继承的类（被final修饰类）
+ 如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法
+ 类中的字段、方法是否与父类产生矛盾（例如覆盖了父类的final字段，或者出现不符合规则的方法重载）

#### 字节码验证(数据流/控制流分析)

+ 保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作
+ 保证跳转指令不会跳转到方法体以外的字节码指令上
+ 保证方法体中的类型转换是有效的

#### 符号引用验证(转化直接引用（解析阶段）)

+ 符号引用中通过字符串描述的全限定名是否能找到对应的类
+ 在指定类中是否存在符合方法的字段描述符以及简单名称所描述的方法和字段
+ 符号引用中的类、字段、方法的访问性是否可以被当前类访问

### 准备

正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程

__符号引用 vs 直接引用__

+ 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
+ 直接引用：可以是直接指向目标的指针、相对偏移量或者是一个可以间接定位到目标的句柄

解析主要包括：

+ 类和接口解析
+ 字段解析
+ 类方法解析
+ 接口方法解析

### 初始化

类初始化阶段是类加载过程的最后一步，初始化阶段是执行类构造器`<clinit>()`方法的过程。`<clinit>()`方法的特点：

+ `<clinit>()`方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(`static {}`)中的语句产生的
+ `<clinit>()`方法与`<init>()`方法不同，它不需要显式地调用父类的构造器，虚拟机会保证在子类的`<clinit>()`方法执行之前，父类的`<clinit>()`方法已经执行完毕
+ 由于父类的`<clinit>()`方法先执行，也就意味着父类中定义的静态语句块要先于子类的类变量赋值操作
+ `<clinit>()`方法对于类和接口来说并不是必须的，如果没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成`<clinit>()`方法
+ 接口中不能使用静态语句块，但仍然有变量初始化的赋值操作
+ 虚拟机会保证一个类的`<clinit>()`方法在多线程环境下被正确地加锁、同步
