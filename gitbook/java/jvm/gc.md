# GC

## GC 概述

### GC 意义

内存处理是编程人员容易出现问题的地方，忘记或者错误的内存回收会导致程序或系统不稳定甚至崩溃。GC机制可以有效地防止内存泄漏，有效地使用空闲的内存。

Java内存泄漏： 指一个内存对象的生命周期超出了程序需要它的时间长度，有时也称为“对象游离”

### GC 要解决的问题

+ 哪些内存需要回收？
+ 什么时候回收？
+ 怎么回收？

## 找出回收对象的算法

### 引用计数法

+ 原理： 给对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器值就减1；任何时刻计数器值为0的对象就是该被回收的对象

+ 优点： 引用计数收集器可以很快执行，对长时间不需要打断的程序比较有利

+ 缺点： 很难解决对象之间的循环引用问题

### 可达性分析

原理： 程序把所有的引用关系看作一张图，从一个节点GC ROOT开始寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕后，剩余的节点则被认为是没有被引用到的节点，即无用节点。

Java 中可以作为GC ROOT的对象有：

+ 虚拟机栈中引用的对象(本地变量表)
+ 方法区中静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法栈中JNI引用的对象(Native对象)

## 垃圾收集算法

### 标记-清除 算法

整个算法分为两个阶段：

+ 标记： 首先标记出所有需要回收的对象(可达性分析)
+ 清除： 标记完成后统一回收被标记为要回收的对象

两个不足：

+ 效率问题： 标记和清除两个过程的效率都不高
+ 空间问题： 标记清除之后会产生大量不连续的内存碎片

### 复制算法

原理： 将可用的内存按容量分为大小相等的两块，每次只使用其中的一块。当这一块内存用完了，就将还存活者的对象复制到另一块内存上，然后再把已经使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存进行回收，内存分配时也就不用考虑内存碎片等复杂情况。

### 标记-整理 算法

算法也是分为两个阶段：

+ 标记： 标记出所有可以回收的对象
+ 整理： 将所有存活的对象都向一端移动，并更新对应的指针，然后清理掉端边界以外的内存

### 分代算法

根据对象存活周期的不同将内存划分为几块，不同周期的对象区域采用不同的垃圾收集算法，以便提高效率：

+ 新生代： 目标是尽可能快速地收集掉那些生命周期短的对象，一般使用复制算法
+ 老年代： 老年代中的对象存活率高，且没有额外的空间对它进行分配担保，采用标记-清除 或者 标记-整理 算法

## 垃圾收集器

+ Serial 收集器： 新生代单线程收集器，复制算法
+ Serial Old 收集器： 老年代单线程收集器，标记整理算法
+ ParNew: 新生代多线程收集器，复制算法
+ Parallel Scavenge： 新生代并行收集器，追求吞吐量，复制算法
+ Parallel Old： 老年代并行收集器，Parallel Scavenge 的老年代版本，标记-整理 算法
+ CMS: 老年代并发收集器，使用标记-整理 算法，追求低停顿，高响应
+ G1： 分区收集算法，面向服务端的收集器，用于多CPU和大内存

## 内存分配与回收策略

### 内存分配策略

#### 优先在Eden空间分配

大多数情况下，对象在新生代的Eden区中分配，当Eden区没有足够空间进行分配时，VM发起一次Minor GC，如果在Minor GC期间发现新生代存活对象无法放入空闲的Survivor区，则会通过空间分配担保机制使对象提前进入老年代

#### 大对象直接进入老年代

超过阈值(通过-XX:PretenureSizeThreshold可配置)对象直接进入老年代，目的是避免在Eden区和Survivor区之间产生大量的内存复制

### 对象晋升

#### 年龄阈值(默认15)

如果对象在Eden出生并且经过一个Minor GC后仍然存活，并能够被Survivor区容纳的话，将被移动到Survivor区，并且对象年龄设为1。以后对象在Survivor区每“熬过”一次Minor GC，年龄就增加1岁。当年龄大于阈值，就会被晋升到老年代中。

#### 提前晋升(动态对象年龄判定)

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代