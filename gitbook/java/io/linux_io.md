# Linux I/O 模型

## 概念说明

+ 基本I/O: 类Unix系统中常用的I/O函数有 `read()` / `wirte()` 等，这些被称为不带缓存的I/O或者基本I/O
+ 标准I/O： 又称为缓存I/O，即在基本I/O上增加了流和缓存的概念，标准I/O为了提高读写效率和保护磁盘，使用了页缓存(page cache)机制

标准I/O的缺点： 数据在传输过程中需要在应用程序地址空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销是非常大的

用户I/O操作都分为两个阶段：等待数据 和 数据拷贝

### 线程稀缺性体现：

1. 线程的创建和销毁的成本很高。在Linux中，线程本质上是一个进程，创建和销毁都是重量级的系统函数
2. 线程本身占用较大的内存。像Java的线程栈，一般至少分配512K~1M的内存空间
3. 线程的切换成本很高。操作系统发生线程切换的时候，需要保留线程的上下文，然后执行系统调用。如果线程数过高，可能执行线程切换的事件甚至大于线程执行的时间
4. 容易造成锯齿状的系统负载。一旦线程数高但外部网络环境不稳定，就很容易造成大量的请求的结果同时返回，激活大量的阻塞线程从而使系统负载压力过大

## Linux I/O 模型

Linux I/O 模型直接影响了 Java I/O 模型，Linux 下有如下常见的I/O模型：

### 阻塞模型

传统的`read()`和`write()`会等待数据包到达并且复制到用户空间缓冲区(或发生错误)时才会返回，在此期间会一直等待

![](img/bio.png)

### 非阻塞模型

在非阻塞I/O的情景下，当用户进程调用`read`系统函数时，如果kernel中的数据没有准备好，那么系统并不会block用户进程，而是立即返回一个error。

![](img/nio.png)

非阻塞I/O的特点是用户进程需要不断地询问kernel数据是否准备好了。

### I/O 多路复用

就是常说的 `select`、`poll`、`epoll`，也被称为 event driven I/O。

I/O 多路复用的特点是通过一种机制让一个进程能够同时等待多个文件描述符，而这些文件描述符其中的任意要给进入可读的就绪状态，`select/poll/epoll`函数就可以立即返回。

![](img/mio.png)

优势： 可以同时处理多个connection

### 异步 I/O

以读为例：用户进程发起read操作后，kernel会立即返回，不会阻塞用户进程，然后kernel会等待数据准备完成，接着将数据拷贝到用户空间进程的缓冲区中。待一切都完成后，kernel会给用户进程发送一个signal通知。

![](img/aio.png)

特点： 整个I/O操作流程中，用户进程始终没有被阻塞。

## Java 网络I/O模型

### BIO 阻塞I/O

服务器每次收到请求后，会启动一个线程来处理连接。或者引入线程池机制，每次收到请求，封装成一个任务提交到线程池执行

### NIO

NIO 底层会根据操作系统选择可用的多路复用机制

特点： socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的(消耗CPU但性能非常高)

### AIO

不但等待就绪是非阻塞的，就连数据从网卡到内存都是非阻塞的
